# 编译器gcc和g++

> 为什么要有编译器？
>
> 文本文件（源文件）变成可执行程序可以称为程序的翻译过程，这个过程可以通过编译器实现。
>
> 之所以有这个翻译过程，是因为计算机不认识。编程语言是比较接近人的自然语言，但计算机的磁盘、内存、CPU寄存器等都是由2种状态的电子元件组成，所以计算机只认识二进制。

## 编译器

编译器也是一种软件，用于将计算机语言翻译成计算机认识的可执行程序。早期没有编译器的概念，因为早期的人们和计算机交互是通过打孔的纸带完成，人将要执行的程序翻译成纸带上的孔洞，计算机会处理纸带上的程序。

CPU可以识别很多被预设的指令，这就是最早的指令集。写在纸带上的孔洞就是表示指令。这些二进制指令可以直接被计算机执行。

> 只要是涉及芯片制作都会有指令集，除了基本的工业设备（例如光刻机），还要设计芯片能支持的指令集，这个指令集是现代计算机最底层的技术。

后来人们觉得这个二进制编程有点费劲（指完成一个程序纸带需要几天，而计算机几秒钟就运行完整个纸带），人们就将二进制指令用若干字符串表示，这些字符串组成了一门汇编语言。

汇编语言比起刻有二进制语言的带孔纸带，观感上好了很多。因为是用字符表示指令，所以汇编语言算是人类的自然语言的半成品。计算机并不认识汇编，汇编诞生的时候顺带诞生了汇编语言翻译成二进制语言的软件（用二进制“写”的翻译软件），这个软件可以认为是**最早的编译器**。这个编译器的工作就是将汇编指令翻译成二进制并交给计算机去执行。

虽然已经能将汇编语言翻译成二进制，再后来人们觉得汇编语言用起来也不是特别好用，于是就诞生了各种高级语言（c、c++、Java、Python等），这些高级语言更接近人的自然语言，新诞生的语言也会伴随适配高级语言的编译器。

以 c 语言为例，尽管可以使用 c 语言实现一个 c 语言直接转换成机器语言的编译器（重走汇编语言的老路），但没有必要，可以先转换成汇编语言，再通过原有的汇编语言编译器翻译。因此早期的 c 语言的编译器用汇编实现，之后只需要将 c 语言给这个编译器，编译器就可以进行翻译工作，翻译的细节用户可以不理会。

我今天拿对应的这个二进制编译器编写的第一版的汇编语言之后，如果拿这个二进制编译器最开始的时候汇编刚出来，此时我们拿二进制写了一个简单的编译器把汇编语言翻译成对应的二进制，此时我们已经能把汇编语言翻译成二进制，此时这是第1个编译器。如果不考虑c、c++语言，单纯在汇编层面上，能否再用汇编语言重写汇编编译器？

可以。**编译器也是软件**，当有最原始的汇编编译器时，刚开始时用旧的汇编语言，拿这个旧的汇编对应的二进制编译器，然后编译形成一个新的编译器，之后新的编译器也能编译汇编，就可以用这个新的编译器重写新的汇编语言。这个过程可以理解为汇编语言的自我更新过程。

所以新诞生的高级语言（例如c语言），就可以使用汇编语言写一个将c语言翻译成汇编的编译器。同理也可以使用c语言实现将汇编语言翻译成c语言的软件。

汇编先给c写一个编译器，就能将c语言编译成二进制，形成对应的软件，第2次再写时照样可以用c语言直接写一个编译器源码，然后用汇编的编译器把c语言写好的编译器源码给编译出来。此时就诞生出了一个用c、c++写的一款编译器。

这一个过程可以称之为**语言或编译器的自举的过程**。

其中 gcc 和 g++ 就是 c 语言和 c++ 的编译器。二者在功能上大体相同，因此重点介绍 gcc。

## gcc

在Linux，gcc 和 g++被放在了 bin 目录，这意味着 gcc 和 g++ 可以像指令一样使用。

```basic
[Bjarne@VM-8-8-centos ~]$ which gcc
/usr/bin/gcc
[Bjarne@VM-8-8-centos ~]$ which g++
/usr/bin/g++
[Bjarne@VM-8-8-centos ~]$ 

```

**格式**：`gcc [选项] 要编译的文件 [选项] [目标文件]`

**功能**：用于将c、c++的文本文件（.c或.cpp）变成可执行程序（.exe）。

> c++的文件拓展名有很多写法：.cpp、.cc、.cxx。
>
> 它们没有区别，g++ 都能识别，包括MSVC。尽管 Linux 认为文件后缀没有意义，但 gcc 和 g++ 会识别后缀。
>
> Linux 使用 .cc 居多，.cpp 是所有场合都有用。

**选项**：

`-E`：只激活预处理，这个不生成文件，需要把它重定向到一个输出文件里面。可以理解成进行程序的翻译，直到处理做完就停止。

`-S`：编译到汇编语言不进行汇编和链接。

`-c`：编译到目标代码。即将汇编语言整理成二进制的可执行文件之后就停下来。

`-o`：文件输出到 文件。

`-static`：此选项对生成的文件采用静态链接。加了这个选项就可以生成静态库。若没有安装静态库，则使用这个选项可能会报错。可执行`yum install glibc-static`。若是c++，则执行`yum install libstdc++-static`。

`-g`：生成调试信息。GNU 调试器可利用该信息。

`-shared`：此选项将尽量使用动态库，所以生成文件比较小，但是需要系统有动态库。

`-O0`、`-O1`、`-O2`、`-O3`：编译器的优化选项的4个级别，`-O0`表示没有优化，`-O1`为缺省值，`-O3`优化级别最高。

`-w`：不生成任何警告信息。

`-Wall`：生成所有警告信息。

`-std=`：指定编译器所使用的标准。例如`-std=c99` 则是指定 c 语言在编译时使用 c99 的标准。

## c语言的编译过程

大致过程：c源文件 $\rightarrow$ 预处理 $\rightarrow$ 编译 $\rightarrow$ 汇编 $\rightarrow$ 链接 $\rightarrow$ 可执行程序。

各个阶段的任务如下：

预处理：

* 预处理功能主要包括宏替换，文件包含，条件编译，去注释等。

* 预处理指令是以 # 号开头的代码行。

* 处理完之后的语言还是 C 语言，但很多内容被替换或删除了。

  实例: `gcc –E hello.c –o hello.i`

  选项 `-E` ，该选项的作用是让 gcc 在预处理结束后停止编译过程。若不使用这 `-E` 及其类似的选项控制进程，则 gcc 会直接将文本文件翻译成可执行文件。

  选项 `-o` 是指目标文件，`.i` 为拓展名的文件是已经过预处理的C原始程序。

  > 编译器在安装时都要有自己的默认搜索路径，所以使用 `<>` 包裹的头文件展开时会将指定路径的文件的内容根据需要选择性地拷贝到现在的代码中，使用 `""` 包括的头文件只会在指定路径查找要展开的头文件。
  >
  > 预处理会**裁掉条件编译为假的内容**。通过条件编译，可以实现对代码的动态裁剪。
  >
  > 在生活中有很多软件，都是同一种软件，但是功能却有差别，有的是收费的，而有的是免费的，例如 Visual Studio 2022，xshell，vmware，都会分专业版和社区版。
  >
  > 若这些软件都是用c、c++实现的，则社区版和专业版都是维护 1 份代码，通过条件编译来裁剪部分高级功能，想升级成专业版也可以修改条件编译，若软件出了 BUG 也只需要修改这一份源码即可。

编译（生成汇编）

* 在这个阶段中，gcc 首先要检查代码的规范性、是否有语法错误等，以确定代码的实际要做的工作，在检查无误后，gcc 把代码翻译成汇编语言。

  用户可以使用 `-S` 选项来进行查看，该选项能将进度截止到生成汇编语言文本。

  实例: `gcc –S hello.i –o hello.s`（可以是`hello.c`，但有了预处理之后的代码，何必再预处理一次）

  ```assembly
  	.file	"a.c"
  	.section	.rodata
  .LC0:
  	.string	"abcde"
  	.text
  	.globl	main
  	.type	main, @function
  main:       # 这个是标签
  .LFB0:
  	.cfi_startproc
  	pushq	%rbp
  	.cfi_def_cfa_offset 16
  	.cfi_offset 6, -16
  	movq	%rsp, %rbp
  	.cfi_def_cfa_register 6
  	movl	$.LC0, %edi
  	call	puts   # 左侧的call、movl等是助记符，右侧的是CPU的寄存器
  	movl	$0, %eax
  	popq	%rbp
  	.cfi_def_cfa 7, 8
  	ret
  	.cfi_endproc
  .LFE0:
  	.size	main, .-main
  	.ident	"GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-44)"
  	.section	.note.GNU-stack,"",@progbits
  
  ```


汇编（生成机器可识别代码）

* 汇编阶段是把编译阶段生成的 “.s” 文件转成二进制的目标文件。这个目标文件可称为**可重定位二进制文件**。

* 在此可使用选项 “-c” 就可看到汇编代码已转化为 “.o” 的二进制目标代码了。

  实例: `gcc –c hello.s –o hello.o`

  查看二进制代码，可使用 `od file`，将它以八进制的方式打印出来。这个 .o 已经是准可执行程序了，相当于已经打好孔的纸带。但它依旧不能运行，即使赋予可执行的权限。

  MSVC 下的拓展名是 .obj。

链接（生成可执行文件或库文件）

* 在成功编译之后,就进入了链接阶段。

  实例: `gcc hello.o –o hello`

  这些 .o 文件加上系统库就形成了可执行程序。链接过程用户一般看不到，都是 .o 一下子就生成了。

> c语言和c++的编译过程基本差不多，但用的软件是g++。
>
> c语言的编译过程产生的中间文件的拓展名可以组成iso，有特殊含义。包括选项ESc，和键位<kbd>ESC</kbd>有相似之处，但c用的小写。
>
> 因为历史上的语言的发展就是从二进制到汇编，再到高级语言的过程，这个过程用了几十年。
>
> 若想绕过汇编语言直接将高级语言翻译成二进制机器语言，首先要面临的问题是成本太高：之前写的 c 语言的编译器就得用二进制机器语言重写，相当于是重新走一遍历史；而将 c 语言翻译成汇编也只是一个字符文本的转换。
>
> 再后来的一些应用场景，c、c++ 这种编译型语言在有些场景处理数据的成本还是比较高，例如对字符串做切割处理，拓展更多的功能包。而且 c++ 的更新也比较慢，所以在c++ 之上诞生了解释型语言。
>
> * Java（半解释型语言，因为有字节码（.class）这个中间产物）
> * Python
> * PHP
>
> 解释型语言都要先安装各种工具包和解释器，而c语言只需要安装对应的库和编译器。这些解释器都是用c、c++写的，这也是为什么有一种“c生万物”的说法。



gcc默认版本是4.8.5，可能不支持C99及之后的语法，例如`for(int i;;){}`。

```basic
[Bjarne@VM-8-8-centos awork]$ gcc -v
# 省略
gcc version 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) 
[Bjarne@VM-8-8-centos awork]$ 

```

想要 gcc 支持 c99 的语法，可以指定标准。

```
[Bjarne@VM-8-8-centos awork]$ gcc a.c -std=c99

```

## 动态库和静态库

gcc在默认情况下生成的可执行程序就是动态链接。

### 动态库和静态库

很多程序员写代码时，编译器和语言通过自举变得越来越好。

在欧美有一群人数庞大（1000人左右）的工程师（科学家），他们每人都需要做一件事：根据情况向显示屏打印消息。或者说早期这些人都有各自的研究领域，他们可能需要使用编程语言编写各种算法（包括数学公式例如三角函数的泰勒公式、打印消息到显示屏上等等）。

因为进行研究之前需要先实现一部分或全部函数，后面要进行算法设计时直接使用已经写好的软件就可以。但所有人都可能自己弄一套属于自己的别人已经做出来的函数，而且还很有可能大部分人写的函数都有BUG，极少数的能用但可能效率差、风格差，能用且效率可观的代码只是少数。更重要的是，工程师除了要懂自己的领域，还要懂编程，要求很高。

于是就分出一批人做一些基础工作：将常用的功能写一份代码即可，让每个工程师都能将资源和精力集中在自己擅长的领域。

> 这种模式并不是特例，在抗日战争时期以及建国后就分出一部分人成立生产建设兵团，专门负责后勤物资的生产和运输，这样可以在保证军队战斗力的同时实现物资的补给。
>
> 更早的时候还有汉代的屯田制度，为了抵御北方少数民族的入侵，就将军队驻扎在北方进行屯田。

C程序中，并没有定义`printf`的函数实现，且在预编译中包含的`stdio.h`中也只有该函数的声明，而没有定义函数的实现。

这时因为系统把这些函数实现都被做到名为 libc.so.6 的库文件中去了，在没有特别指定时，gcc 会到系统默认的搜索路径`/usr/lib`下进行查找，也就是链接到 `libc.so.6` 库函数中去，这样就能实现函数`printf`了，而这也就是链接的作用。

函数库一般分为静态库和动态库两种。

* 静态库是指编译链接时，把**库文件的代码全部加入到可执行文件**中，因此生成的文件比较大，但在运行时也就不再需要库文件了。在Linux，后缀名为“.a”；在windows，后缀名为“.dll”。
* 动态库与之相反，在编译链接时并没有把库文件的代码加入到可执行文件中，而是在**程序执行时由运行时链接文件加载库**，这样可以节省系统的开销。动态库在Linux的后缀名为“.so”,如前面所述的 libc.so.6 就是动态库。在windows，后缀名为“.lib”。
  库中所有的函数都有入口地址，所谓的动态链接，其实就是要连接的库中的函数地址拷贝到可执行程序的特定位置。

c语言的头文件大都在这里。

```basic
[Bjarne@VM-8-8-centos work]$ ls /usr/include

```



gcc 在编译时默认使用动态库。完成了链接之后，gcc 就可以生成可执行文件，如下所示。 `gcc hello.o –o hello`

gcc默认生成的二进制程序，是动态链接的，这点可以通过 file 命令验证。

但无论是动态库还是静态库，在 Linux 都可以通过 `./file` 运行。

### ldd指令查看第三方库

`ldd 可执行程序` 可查看当前的可执行程序调用的库的位置。

```basic
[Bjarne@VM-8-8-centos cppTest]$ ls
a.c  a.exe  a.i  a.o  a.s
[Bjarne@VM-8-8-centos cppTest]$ ldd a.exe
	linux-vdso.so.1 =>  (0x00007ffce5ffd000)
	libc.so.6 => /lib64/libc.so.6 (0x00007f48e864c000) # 第三方库
	/lib64/ld-linux-x86-64.so.2 (0x00007f48e8a1a000)
[Bjarne@VM-8-8-centos cppTest]$ 
```

`libc.so.6 => /lib64/libc.so.6 (0x00007f48e864c000)` 就是`printf` 背后的库。程序员写的c语言、c++程序实际就是 `自己的代码 + 头文件 + 库 = 可执行程序`。

开发环境的安装，就是将这些库配置到本地的计算机中。

库的命名规则：以 lib 开头，第2个 so 表示动态库，最后1个数字是版本号。把这些组成去掉后才是库真正的名字，即 libc.so.6 ，真正的名字是 c，表示C标准库。同理 libc.a 也能将 lib 和 .a 去掉，它也表示C标准库，但是是静态库。

Linux 中装的大多是动态库，静态库比动态库少。

```basic
[Bjarne@VM-8-8-centos ~]$ ls /lib64/libc.so.6
/lib64/libc.so.6
[Bjarne@VM-8-8-centos ~]$ ls /lib64/libc.so.6 -l
lrwxrwxrwx 1 root root 12 Jul  8  2024 /lib64/libc.so.6 -> libc-2.17.so # 表示这个是链接文件
[Bjarne@VM-8-8-centos ~]$ ls /lib64/*.a
/lib64/libbsd.a # 省略其他 lib文件名.a 格式的静态库
[Bjarne@VM-8-8-centos ~]$ 
```

在 windows，动态库的拓展名是 .dll ，静态库的拓展名 .lib 。

> 这个 .dll 动态库也出现的比较多。个人的话因为一些软件（例如Typora）需要某个动态库支持才能使用，但杀毒软件总是将这个 .dll 识别为病毒并将它清理掉，因此不得不采取一些不常规的手段，比如将这个文件列入白名单。
>
> 在Linux，可以用ldd查看指令，绝大部分都要调用这个库。若其他普通用户不可调用这个动态库（比如删了或者修改权限），则Linux的指令多半不可用。若是删了则后果更严重，除了重装系统别无办法（因为文件拷贝也要这个库支持）。

c语言的编译过程中只有链接和第3方库有关。

假设一高中生，上网的时候去网吧，说白了就是一个共享机器，用一点钱租借机器几个小时。类比的话高中就是**内存**，自己就是**软件**，学长是**编译器中的模块或连接器**，自己找学长打听网吧信息的过程叫**链接**，网吧就是**动态库**，网吧中的机器就是**要调用的函数**，在网吧计划要玩的游戏叫**要执行的代码**。有一天网吧被帽子叔叔给端了，这个高中生就把电脑带到宿舍去玩，这时这个被带进学校的电脑就是**静态库**。

> 还有一个话吧的概念，随着互联网的发展被淘汰。之前没电脑，于是就有座机作为临时的共享电话。
>
> 所以动态库又可以称之为共享库。

### 动、静态库的优、缺点

动态库的优点：形成的可执行程序体积比较小，比较节省空间。

动态库的缺点：速度对比静态链接可能会比较慢。而且对外置动态库有很强的依赖，一旦外置动态库没了，则整个程序将无法使用。

静态库的优点：无视库，可以独立运行。

静态库的缺点：体积大，浪费资源。同一个代码生成的动态库，是同一个代码生成的静态库的$\frac{1}{70}$。

目前的操作系统大都使用动态库。

> 我们的开发环境，都要做这些事：
>
> 1. 下载开发环境，以及提供 `#include`的头文件和 .lib。
> 2. 设置合理的查找路径。
> 3. 规定好形成可执行程序的链接方式。